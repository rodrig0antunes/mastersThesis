## Example
void write_hello_string (char *buf, char *path)
{
	PMEMobjpool *pop;
	
    pop = pmemobj_create(path, LAYOUT, PMEMOBJ_MIN_POOL, 0666);
	
    if (pop == NULL) 
	{
		perror(path);
		exit(1);
	}

	PMEMoid root = pmemobj_root(pop, sizeof (struct my_root));
    struct my_root *rootp = pmemobj_direct(root);
    
    rootp->len = strlen(buf);
    
    printf("\nWrite the (%s) string to persistent-memory.\n", rootp->buf);
	pmemobj_close(pop);	

	return;
}
## Correction
void write_hello_string (char *buf, char *path)
{
	PMEMobjpool *pop;
	
    pop = pmemobj_create(path, LAYOUT, PMEMOBJ_MIN_POOL, 0666);
	
    if (pop == NULL) 
	{
		perror(path);
		exit(1);
	}

	PMEMoid root = pmemobj_root(pop, sizeof (struct my_root));
    struct my_root *rootp = pmemobj_direct(root);
    
    rootp->len = strlen(buf);
    
    pmemobj_persist(pop, &rootp->len, sizeof (rootp->len));
	
    printf("\nWrite the (%s) string to persistent-memory.\n", rootp->buf);
	pmemobj_close(pop);	

	return;
}
## Explanation
In the correction, after the update 'rootp->len', it needs to be included 'pmemobj_persist(pop, &rootp->len, sizeof (rootp->len));' to ensure that the value of 'rootp->len' is durably stored in the persistent memory pool. 
By adding 'pmemobj_persist(pop, &rootp->len, sizeof(rootp->len));', it is guaranteed that the assignment to 'rootp->len' is properly preserved, and the data remains consistent. This correction ensures data durability in persistent memory.
