### Correction of the INCORRECT PERSISTENT MEMORY PROGRAM

``` C
/*
 * hm_atomic_insert -- inserts specified value into the hashmap,
 * returns:
 * - 0 if successful,
 * - 1 if value already existed,
 * - -1 if something bad happened
 */
int
hm_atomic_insert(PMEMobjpool *pop, TOID(struct hashmap_atomic) hashmap,
		uint64_t key, PMEMoid value)
{
	TOID(struct buckets) buckets = D_RO(hashmap)->buckets;
	TOID(struct entry) var;

	uint64_t h = hash(&hashmap, &buckets, key);
	int num = 0;

	POBJ_LIST_FOREACH(var, &D_RO(buckets)->bucket[h], list) {
		if (D_RO(var)->key == key)
			return 1;
		num++;
	}

	PM_EQU(D_RW(hashmap)->count_dirty, 1);
	pmemobj_persist(pop, &D_RW(hashmap)->count_dirty,
			sizeof(D_RW(hashmap)->count_dirty));

	struct entry_args args = {
		.key = key,
		.value = value,
	};
	PMEMoid oid = POBJ_LIST_INSERT_NEW_HEAD(pop,
			&D_RW(buckets)->bucket[h],
			list, sizeof(struct entry), create_entry, &args);
	if (OID_IS_NULL(oid)) {
		fprintf(stderr, "failed to allocate entry: %s\n",
			pmemobj_errormsg());
		return -1;
	}
		
	// BUG //

	PM_EQU(D_RW(hashmap)->count, (D_RW(hashmap)->count + 1));
	pmemobj_persist(pop, &D_RW(hashmap)->count,
			sizeof(D_RW(hashmap)->count));

	PMTest_isPersistedBefore(&D_RW(hashmap)->count_dirty, sizeof(D_RW(hashmap)->count_dirty), &D_RW(hashmap)->count, sizeof(D_RW(hashmap)->count));

	PM_EQU(D_RW(hashmap)->count_dirty, 0);
	pmemobj_persist(pop, &D_RW(hashmap)->count_dirty,
			sizeof(D_RW(hashmap)->count_dirty));
		
	// BUG //

	PMTest_isPersistedBefore(&D_RW(hashmap)->count, sizeof(D_RW(hashmap)->count), &D_RW(hashmap)->count_dirty, sizeof(D_RW(hashmap)->count_dirty));

	num++;
	if (num > MAX_HASHSET_THRESHOLD ||
			(num > MIN_HASHSET_THRESHOLD &&
			D_RO(hashmap)->count > 2 * D_RO(buckets)->nbuckets))
		hm_atomic_rebuild(pop, hashmap, D_RW(buckets)->nbuckets * 2);

	PMTest_isPersistent(&D_RW(hashmap)->count_dirty, sizeof(D_RW(hashmap)->count_dirty));
	PMTest_isPersistent(&D_RW(hashmap)->count, sizeof(D_RW(hashmap)->count));

	return 0;
}
```

### Explanation
In the example, there are two bugs to repair, each delimited by the '// BUG //' expressions.

1. The first bug is related to the order of operations. The value of 'D_RW(hashmap)->count' is updated, but it is not persisted before the check in 'PMTest_isPersistedBefore'. To fix this bug, the call to 'pmemobj_persist' is moved before the check in 'PMTest_isPersistedBefore'.

2. The second bug is also related to the order of operations. The value of 'D_RW(hashmap)->count_dirty' is updated, but it is not persisted before the check in 'PMTest_isPersistedBefore'. To fix this bug, the call to 'pmemobj_persist' is moved before the check in 'PMTest_isPersistedBefore'.

By making these changes, the updated values of 'D_RW(hashmap)->count' and 'D_RW(hashmap)->count_dirty' are correctly persisted before the checks in 'PMTest_isPersistedBefore'. This ensures that the data is durably stored in persistent memory and can be reliably checked for persistence.