To resolve the bug, we need to fix the code inside the delimited area. 

Looking at the code, it seems that the bug is related to the use of the `PM_EQU` macro. The `PM_EQU` macro is not a standard function or macro in the PMDK library. It seems that the user intended to use the `PMEMobj_memcpy_persist` function to copy the data from one persistent memory location to another.

To fix the bug, we need to replace the `PM_EQU` macro with the `PMEMobj_memcpy_persist` function. Here's the corrected code:

``` C
/*
 * btree_map_rotate_right -- (internal) takes one element from right sibling
 */
static void
btree_map_rotate_right(TOID(struct tree_map_node) rsb,
	TOID(struct tree_map_node) node,
	TOID(struct tree_map_node) parent, int p)
{
	/* move the separator from parent to the deficient node */
	struct tree_map_node_item sep = D_RO(parent)->items[p];
	btree_map_insert_item(node, D_RO(node)->n, sep);
		
	// BUG //
	
	/* the first element of the right sibling is the new separator */
	PMEMobj_memcpy_persist(pop, &D_RW(parent)->items[p], &D_RO(rsb)->items[0], sizeof(struct tree_map_node_item));
		
	// BUG //

	/* the nodes are not necessarily leafs, so copy also the slot */
	TX_ADD_FIELD(node, slots[D_RO(node)->n]);
	PMEMobj_memcpy_persist(pop, &D_RW(node)->slots[D_RO(node)->n], &D_RO(rsb)->slots[0], sizeof(TOID(struct tree_map_node)));

	TX_ADD(rsb);
	D_RW(rsb)->n = D_RO(rsb)->n - 1; /* it loses one element, but still > min */

	/* move all existing elements back by one array slot */
	PMEMobj_memmove_persist(pop, D_RW(rsb)->items, D_RO(rsb)->items + 1,
		sizeof(struct tree_map_node_item) * (D_RO(rsb)->n));
	PMEMobj_memmove_persist(pop, D_RW(rsb)->slots, D_RO(rsb)->slots + 1,
		sizeof(TOID(struct tree_map_node)) * (D_RO(rsb)->n + 1));
}
```

In the corrected code, we have replaced the `PM_EQU` macro with the `PMEMobj_memcpy_persist` function to copy the data from the right sibling to the parent node. We have also replaced the `PM_MEMMOVE` macro with the `PMEMobj_memmove_persist` function to move the existing elements in the right sibling.

Note that we assume that the `pop` variable is a valid `PMEMobjpool` object that is accessible in the current scope. If it is not, you may need to adjust the code accordingly.