\n\n### CORRECTED PERSISTENT MEMORY PROGRAM\n``` C\n/*\n* rbtree_map_rotate -- (internal) performs a left/right rotation around a node\n*/\nstatic void\nrbtree_map_rotate(TOID(struct rbtree_map) map,\nTOID(struct tree_map_node) node, enum rb_children c)\n{\nTOID(struct tree_map_node) child = D_RO(node)->slots[!c];\nTOID(struct tree_map_node) s = D_RO(map)->sentinel;\n\nTX_ADD(node);\nTX_ADD(child);\n\nPM_EQU(D_RW(node)->slots[!c], D_RO(child)->slots[c]);\n\nif (!TOID_EQUALS(D_RO(child)->slots[c], s))\nTX_SET(D_RW(child)->slots[c], parent, node);\n\n// BUG#1 //\n\nPM_EQU(NODE_P(child), NODE_P(node));\n\nTX_ADD(NODE_P(node));\nPM_EQU(NODE_PARENT_AT(node, NODE_LOCATION(node)), child);\nTX_SET(NODE_P(node), slots[NODE_LOCATION(node)], child);\n\nPM_EQU(D_RW(child)->slots[c], node);\nPM_EQU(D_RW(node)->parent, child);\n\n// BUG#1 //\n\n}\n\n/*\n* rbtree_map_remove -- removes key-value pair from the map\n*/\nPMEMoid\nrbtree_map_remove(PMEMobjpool *pop, TOID(struct rbtree_map) map, uint64_t key)\n{\nPMEMoid ret = OID_NULL;\n\nTOID(struct tree_map_node) n = rbtree_map_find_node(map, key);\nif (TOID_IS_NULL(n))\nreturn ret;\n\nret = D_RO(n)->value;\n\nTOID(struct tree_map_node) s = D_RO(map)->sentinel;\nTOID(struct tree_map_node) r = D_RO(map)->root;\n\nTOID(struct tree_map_node) y = (NODE_IS_NULL(D_RO(n)->slots[RB_LEFT]) ||\nNODE_IS_NULL(D_RO(n)->slots[RB_RIGHT]))\n? n : rbtree_map_successor(map, n);\n\nTOID(struct tree_map_node) x = NODE_IS_NULL(D_RO(y)->slots[RB_LEFT]) ?\nD_RO(y)->slots[RB_RIGHT] : D_RO(y)->slots[RB_LEFT];\n\nTX_BEGIN(pop) {\nTX_SET(x, parent, NODE_P(y));\n\n// BUG#2 //\n\nif (TOID_EQUALS(NODE_P(x), r)) {\nTX_SET(r, slots[RB_LEFT], x);\n} else {\nTX_ADD(y);\nPM_EQU(NODE_PARENT_AT(y, NODE_LOCATION(y)), x);\nTX_SET(NODE_P(y), slots[NODE_LOCATION(y)], x);\n\n// BUG#2 //\n\n}\n\nif (D_RO(y)->color == COLOR_BLACK)\nrbtree_map_repair(map, x);\n\nif (!TOID_EQUALS(y, n)) {\nTX_ADD(y);\nPM_EQU(D_RW(y)->slots[RB_LEFT], D_RO(n)->slots[RB_LEFT]);\nPM_EQU(D_RW(y)->slots[RB_RIGHT], D_RO(n)->slots[RB_RIGHT]);\nPM_EQU(D_RW(y)->parent, D_RO(n)->parent);\nPM_EQU(D_RW(y)->color, D_RO(n)->color);\nTX_SET(D_RW(n)->slots[RB_LEFT], parent, y);\nTX_SET(D_RW(n)->slots[RB_RIGHT], parent, y);\n\n// BUG#3 //\n\nTX_ADD(NODE_P(n));\nPM_EQU(NODE_PARENT_AT(n, NODE_LOCATION(n)), y);\nTX_SET(NODE_P(n), slots[NODE_LOCATION(n)], y);\n\n// BUG#3 //\n\n}\nTX_FREE(n);\n} TX_END\n\nreturn ret;\n}\n```